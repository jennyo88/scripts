#!/usr/bin/env bash

# Convert
# Author: Jennifer Romero
# Description: This script provides a menu-driven interface to convert files
# Version: 4.0
# Last Updated: Feb 24, 2024
# GitHub Repository: https://github.com/jennyo88/scripts


main_menu="0"

# -----------------------------------
# COLORS
# -----------------------------------

load_colors() {
	BLUE=$'\e[38;5;39m'	    	# Blue color
	ORANGE=$'\e[38;5;208m'	# Orange color
	RED=$'\e[1;31m'		# Red color (bold)
	RESET=$'\e[0m'		# Reset color attributes
}

# Calling the load_colors() function to set color variables
load_colors # Only loaded once

# -----------------------------------
# REQUIREMENTS
# -----------------------------------

# Check if required commands are available

check_ydl() {
	if command -v youtube-dl &> /dev/null; then
		return 0  # Success
   	else
        	echo "Error: youtube-dl is not installed. Please install it before running this script."
        	return 1  # Failure
    	fi
}

check_ytdl() {
    	if command -v yt-dlp &> /dev/null; then
        	return 0  # Success
    	else
        	echo "Error: yt-dlp is not installed. Please install it before running this script."
        	return 1  # Failure
    fi
}

check_ffmpeg() {
    	if command -v ffmpeg &> /dev/null; then
        	return 0  # Success
    	else
        	echo "Error: ffmpeg is not installed. Please install it before running this script."
        	return 1  # Failure
    	fi
}

check_wget() {
    	if command -v wget &> /dev/null; then
        	return 0  # Success
    	else
        	echo "Error: wget is not installed. Please install it before running this script."
        	return 1  # Failure
    fi
}

# -----------------------------------
# ABORT
# -----------------------------------

prompt() {
	local prompt="$1"
    	local variable="$2"
    	local default_value="$3"

    	while true; do
        	printf "$prompt"

        	# Set the default value if user presses Enter
        	read -r "$variable"
        	[ -z "${!variable}" ] && eval "$variable=\"$default_value\""

        	# Check if the user wants to abort
        	if [ "${!variable}" == "abort" ]; then
            		sleep 1
            		echo "Abort..."
            		# Add exit actions here if needed
            		show_menu_0
        	fi

        	# Break the loop if input is not empty
        	[ -n "${!variable}" ] && break
    	done
}



# -----------------------------------
# PAUSE & GOODBYE
# -----------------------------------

# Function to pause and wait for user input
pause() {
	echo
	read -rp "Press ENTER to continue..." fackEnterKey
}

# Function to display goodbye message and exit
goodbye() {
	echo -e "${RESET}"
	clear
	exit
}

# -----------------------------------
# BANNERS
# -----------------------------------

# Function to display the main menu banner
show_banner_0() {
	clear
    	echo "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║          Converting Files - Service Menu        ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"
}

show_banner_1() {
    	echo "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                                                 ║ "
    	echo " ║                     VIDEOS                      ║ "
    	echo " ║                                                 ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"
}

show_banner_2() {
    	echo "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                                                 ║ "
    	echo " ║                      SUBS                       ║ "
    	echo " ║                                                 ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"
}

show_banner_3() {
    	echo "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
   	echo " ║                                                 ║ "
    	echo " ║                    CLEAN-UP                     ║ "
    	echo " ║                                                 ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"
}

# -----------------------------------
# MENUS
# -----------------------------------

# Function for displaying the main menu
show_menu_0() {
    	show_banner_0
    	echo ""
    	echo ""
	echo "		SCRIPTS"
	echo " 1. For videos"
	echo " 2. For subtitles"
	echo " 3. For clean-up"
    	echo ""
    	echo ""
	echo " 0. Exit script"
    	echo ""

    	# Prompting the user to select an option
	echo -e "${BLUE}"
	prompt "Select: " ans
	echo "${RESET}"

   	# Handling the user's choice using a case statement
    	case $ans in
        	[vV]|[vV][iI][dD][eE][oO][sS]|"1")
            		show_menu_1
            		;;
        	[sS]|[sS][uU][bB][sS]|"2")
            		show_menu_2
           		;;
        	[cC]|[cC][lL][eE][aA][nN][uU][pP]|"3")
            		show_menu_3
            		;;
        	[eE]|[eE][xX][iI][tT]|[qQ]|"0")
            		# Exiting script
            		goodbye
            		;;
        	# Hidden options
        	[xX][2][6][5]|[1][6])
			clear
            		show_banner_1
            		x265
            		;;
        	[mM][3][uU][8]|[1][2])
			clear
            		show_banner_1
            		m3u8
            		;;
        	[yY][dD][lL]|[1][3])
			clear
            		show_banner_1
            		ydl
            		;;
        	[tT][uU][bB][iI]|[1][5])
			clear
            		show_banner_1
            		tubi
            		;;
        	[mM][eE][tT][aA][dD][aA][tT][aA]|[1][9])
			clear
            		show_banner_1
            		metadata
            		;;
        	[pP][lL][eE][xX]|[1][7])
			clear
            		show_banner_1
            		plex
            		;;
        	[aA][lL][lL]|[1][8])
			clear
            		show_banner_1
            		video_sub && sleep 1
            		c_all
            		;;
        	[eE][xX][tT][rR][aA][cC][tT]|[2][2])
			clear
            		show_banner_2
            		extract_srt
            		;;
        	[vV][tT][tT]|[2][3])
			clear
            		show_banner_2
            		convert_srt
            		;;
        	[cC][aA][lL][lL]|[3][4])
			clear
            		show_banner_3
            		c_all
            		;;
		# Handling invalid options
        	*)
            		echo -e "Invalid option. Please enter a valid option."
            		sleep 1
            		show_menu_0
            		;;
    	esac
}


# Function for displaying the VIDEOS menu
show_menu_1() {
	show_banner_0
	show_banner_1
	echo ""
  	echo "  1. Go back to Main Menu"
	echo ""
	echo "		DOWNLOAD"
  	echo "  2. Download m3u8 playlist"
	echo "  3. Download using youtube-dl"
	echo "  4. Download using yt-dlp"
	echo "  5. Download from tubi"
	echo ""
	echo " 		CONVERT"
  	echo "  6. Convert video to x265"
	echo "  7. Convert ONLY video"
	echo "  8. Convert video & subtitles"
	echo "  9. Encode metadata"
    	echo ""
	echo " 10. Go to SUBS Menu"
	echo " 11. Go to CLEAN-UP Menu"
    	echo ""
    	echo ""
    	echo "  0. Exit script"
    	echo ""

   	# Prompting the user to select an option
	echo -e "${BLUE}"
	prompt "Select: " ans
	echo "${RESET}"

	# Handling the user's choice using a case statement
	case $ans in
      		[mM][aA][iI][nN]|"1")
			clear
			show_banner_0
        		show_menu_0
        		;;
      		[mM]|[mM][3][uU][8]|[dD][2]|"2")
			clear
			show_banner_1
        		m3u8
        		;;
      		[yY]|[yY][dD][lL]|[dD][3]|"3")
			clear
        		show_banner_1
			ydl
        		;;
		[yY][tT]|[dD][4]|"4")
			clear
			show_banner_1
			ytdl
			;;
      		[tT]|[tT][uU][bI][iI]|[dD][5]|"5")
			clear
			show_banner_1
        		tubi
        		;;
      		[xX]|[xX][2][6][5]|[cC][6]|"6")
			clear
			show_banner_1
        		x265
        		;;
		[vV]|[vI][iI][vV][eE][oO]|[cC][7]|"7")
			clear
			show_banner_0
			plex
			c_ts
			;;
		[aA]|[aA][lL][lL]|[cC][8]|"8")
			clear
			show_banner_0
			video_sub && sleep 1
			c_ts
			c_mkv
			;;
		[lL]|[mM][eE][tT][aA][dD][aA][tT][aA]|[cC][9]|"9")
			clear
			show_banner_1
			metadata
			;;
		[sS]|[sS][uU][bB][sS]|"10")
			show_banner_2
			show_menu_2
			;;
		[cC]|[cC][lL][eE][aA][nN][uU][pP]|"11")
			show_banner_3
			show_menu_3
			;;
      		[eE]|[eE][xX][iI][Tt]|"0")
			# Exiting the menu
        		goodbye
        		;;
		# Handling invalid options
        	*)
            		echo -e "Invalid option. Please enter a valid option."
            		pause
            		show_menu_1
            		;;
    	esac
}

# Function for displaying the SUBS menu
show_menu_2() {
	show_banner_0
	show_banner_2
    	echo ""
    	echo ""
    	echo " 1. Go back to Main Menu"
    	echo ""
  	echo " 2. Extract subtitles"
  	echo " 3. Convert subtitles"
	echo ""
  	echo " 4. Go to VIDEOS Menu"
	echo " 5. Go to CLEAN-UP Menu"
    	echo ""
    	echo ""
    	echo " 0. Exit script"
    	echo ""

	# Prompting the user to select an option
  	echo -e "${BLUE}"
	prompt "Select: " ans
	echo "${RESET}"

	# Handling the user's choice using a case statement
    	case $ans in
      		[mM][aA][iI][nN]|"1")
        		show_banner_0
        		show_menu_0
        		;;
      		[eE]|[eE][xX][tT][rR][aA][cC][tT]|"2")
			clear
			show_banner_2
        		extract_srt
        		;;
      		[cC]|[cC][oO][nN][vV][eE][rR][tT]|"3")
			clear
			show_banner_2
        		convert_srt
        		;;
      		[vV]|[vV][iI][dD][eE][oO][sS]|"4")
			show_banner_1
        		show_menu_1
        		;;
		[cC]|[cC][lL][eE][aA][nN][uU][pP]|"5")
			show_banner_3
			show_menu_3
			;;
      		[eE]|[eE][xX][iI][tT]|[qQ]|"0")
			# Exiting the menu
        		goodbye
        		;;
		# Handling invalid options
        	*)
            		echo -e "Invalid option. Please enter a valid option."
            		pause
            		show_menu_2
            		;;
    	esac
}

# Function for displaying the CLEAN-UP menu
show_menu_3() {
	show_banner_0
	show_banner_3
    	echo ""
    	echo ""
    	echo " 1. Go back to Main Menu"
    	echo ""
  	echo " 2. Clear folder ts"
  	echo " 3. Clear folder mkv"
	echo " 4. Clear both folders"
	echo ""
	echo " 5. Go to VIDEOS Menu"
	echo " 6. Go to SUBS Menu"
    	echo ""
    	echo ""
    	echo " 0. Exit script"
    	echo ""

	# Prompting the user to select an option
  	echo -e "${BLUE}"
	prompt "Select: " ans
	echo "${RESET}"

	# Handling the user's choice using a case statement
    	case $ans in
      		[mM][aA][iI][nN]|"1")
        		show_banner_0
        		show_menu_0
        		;;
      		[c][tT][sS]|"2")
			clear
			show_banner_3
        		c_ts
        		;;
      		[c][mM][kK][vV]|"3")
			clear
			show_banner_3
        		c_mkv
        		;;
		[cC][aA][lL][lL]|"4")
			clear
			show_banner_3
			c_all
			;;
      		[vV]|[vV][iI][dD][eE][oO][sS]|"5")
			show_banner_1
        		show_menu_1
        		;;
		[sS]|[sS][uU][bB][sS]|"6")
			show_banner_2
			show_menu_2
			;;
      		"0")
			# Exiting the menu
        		goodbye
        		;;
		# Handling invalid options
        	*)
            		echo -e "Invalid option. Please enter a valid option."
            		pause
            		show_menu_3
            		;;
    	esac
}


# -----------------------------------
# SUBTITLE FORMULAS
# -----------------------------------

# Function to extract subtitles from video files and save as SRT
# This function prompts the user for source and destination directories,
# source and destination extensions, then iterates through all files
# in the source directory with the specified source extension,
# extracting subtitles using FFmpeg, and saving them in the destination directory
# with the specified destination extension.
#
extract_srt() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║              Extract subtitles SCRIPT           ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Prompting the user for the source extension (e.g., mp4, mkv)
	prompt "Source extension? : " srcExt

	# Prompting the user for the destination extension (e.g., srt)
	prompt "Destination extension? (default: srt): " destExt
	destExt=${destExt:-srt}

	# Prompting the user for the source directory
  	prompt "Source directory? : " srcDir

	# Prompting the user for the destination directory
  	prompt "Destination directory? : " destDir
	destDir=${destDir:-srt}

	# Loop through each file in the source directory with the specified source extension
  	for filename in "$srcDir"/*.$srcExt
	do
		# Extracting the base name and path without the extension
  		basePath=${filename%.*}
    		baseName=${basePath##*/}

		# Using FFmpeg to extract subtitles and save as SRT in the destination directory
  		ffmpeg -f lavfi -i "movie="$filename"[out0+subcc]" -map s "$destDir"/"$baseName".en."$destExt"
  	done

  	echo -e "Conversion from ${srcExt} to ${destExt} complete!\a"
	pause
	show_menu_2
}

# Function to convert VTT subtitles to SRT format
# This function prompts the user for source and destination directories,
# then iterates through all VTT files in the source directory,
# converting each to SRT format using FFmpeg and saving them in the destination directory.
#
convert_srt() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║              Convert Subtitles SCRIPT           ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"

	# Prompting the user for the source directory
  	prompt "Source directory? (default: vtt): " srcDir
	srcDir=${srcDir:-vtt}

	# Prompting the user for the destination directory
  	prompt "Destination directory? (default: srt): " destDir
	destDir=${destDir:-srt}

	# Loop through each VTT file in the source directory
  	for filename in "$srcDir"/*.vtt
	do
		# Extracting the base name and path without the extension
  		basePath=${filename%.*}
    		baseName=${basePath##*/}

		# Using FFmpeg to convert VTT to SRT and save the file in the destination directory
  		ffmpeg -i $filename "$destDir"/"$baseName".srt
  	done

  	echo -e "Conversion from vtt to srt complete!\a"
	pause
	show_menu_2
}

# -----------------------------------
# CLEAN-UP FORMULAS
# -----------------------------------

# Function to clean up 'ts' folder
# This function prompts the user for confirmation and, if confirmed, removes all files with .ts extension in the 'ts' folder.
#
c_ts() {
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                CLEAN-UP ts SCRIPT               ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Prompting the user for confirmation
	prompt 'Do you want to clear ts folder (y/N)? ' ans

	# Checking if the user entered 'y' or 'Y' to proceed with cleanup
	if [ "$ans" != "${ans#[Yy]}" ]
	then
		# Removing all files with .ts extension in the 'ts' folder
		rm -r ./ts/*.ts

		echo -e "TS folder cleared!\a"
		sleep 1
		show_menu_3
	fi
}

# Function to clean up 'mkv' folder
# This function prompts the user for confirmation and, if confirmed, removes all files with .mkv extension in the 'mkv' folder.
#
c_mkv() {
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                CLEAN-UP mkv SCRIPT              ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"

	# Prompting the user for confirmation
	prompt 'Do you want to clear mkv folder (y/N)? ' ans

	# Checking if the user entered 'y' or 'Y' to proceed with cleanup
	if [ "$ans" != "${ans#[Yy]}" ]
	then
		# Removing all files with .mkv extension in the 'mkv' folder
		rm -r ./mkv/*.mkv

		echo -e "MKV folder cleared!\a"
		sleep 1
		show_menu_3
	fi
}

# Function to clean up all folders
# This function prompts the user for confirmation and, if confirmed, removes all files in the 'ts' and 'mkv' folders.
#
c_all() {
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                Full CLEAN-UP SCRIPT             ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"

	# Prompting the user for confirmation
	prompt 'Do you want to clear all folders (y/N)? ' ans

	# Checking if the user entered 'y' or 'Y' to proceed with cleanup
	if [ "$ans" != "${ans#[Yy]}" ]
	then
		# Removing all files with .ts extension in the 'ts' folder
 		rm -r ./ts/*.ts

		# Removing all files with .mkv extension in the 'mkv' folder
		rm -r ./mkv/*.

		echo -e "All folders cleared!\a"
		sleep 1
		show_menu_3
	fi
}

# -----------------------------------
# INFINITE LOOP
# -----------------------------------

while true
do
	show_banner_0 && show_menu_${main_menu}
done
