#!/usr/bin/env bash

# Convert
# Author: Jennifer Romero
# Description: This script provides a menu-driven interface to convert files
# Version: 4.0
# Last Updated: Feb 24, 2024
# GitHub Repository: https://github.com/jennyo88/scripts


main_menu="0"

# -----------------------------------
# COLORS
# -----------------------------------

load_colors() {
	BLUE=$'\e[38;5;39m'	    	# Blue color
	ORANGE=$'\e[38;5;208m'	# Orange color
	RED=$'\e[1;31m'		# Red color (bold)
	RESET=$'\e[0m'		# Reset color attributes
}

# Calling the load_colors() function to set color variables
load_colors # Only loaded once

# -----------------------------------
# REQUIREMENTS
# -----------------------------------

# Check if required commands are available

check_ydl() {
	if command -v youtube-dl &> /dev/null; then
		return 0  # Success
   	else
        	echo "Error: youtube-dl is not installed. Please install it before running this script."
        	return 1  # Failure
    	fi
}

check_ytdl() {
    	if command -v yt-dlp &> /dev/null; then
        	return 0  # Success
    	else
        	echo "Error: yt-dlp is not installed. Please install it before running this script."
        	return 1  # Failure
    fi
}

check_ffmpeg() {
    	if command -v ffmpeg &> /dev/null; then
        	return 0  # Success
    	else
        	echo "Error: ffmpeg is not installed. Please install it before running this script."
        	return 1  # Failure
    	fi
}

check_wget() {
    	if command -v wget &> /dev/null; then
        	return 0  # Success
    	else
        	echo "Error: wget is not installed. Please install it before running this script."
        	return 1  # Failure
    fi
}

# -----------------------------------
# ABORT
# -----------------------------------

prompt() {
	local prompt="$1"
    	local variable="$2"
    	local default_value="$3"

    	while true; do
        	printf "$prompt"

        	# Set the default value if user presses Enter
        	read -r "$variable"
        	[ -z "${!variable}" ] && eval "$variable=\"$default_value\""

        	# Check if the user wants to abort
        	if [ "${!variable}" == "abort" ]; then
            		sleep 1
            		echo "Abort..."
            		# Add exit actions here if needed
            		show_menu_0
        	fi

        	# Break the loop if input is not empty
        	[ -n "${!variable}" ] && break
    	done
}



# -----------------------------------
# PAUSE & GOODBYE
# -----------------------------------

# Function to pause and wait for user input
pause() {
	echo
	read -rp "Press ENTER to continue..." fackEnterKey
}

# Function to display goodbye message and exit
goodbye() {
	echo -e "${RESET}"
	clear
	exit
}

# -----------------------------------
# BANNERS
# -----------------------------------

# Function to display the main menu banner
show_banner_0() {
	clear
    	echo "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║          Converting Files - Service Menu        ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"
}

show_banner_1() {
    	echo "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                                                 ║ "
    	echo " ║                     VIDEOS                      ║ "
    	echo " ║                                                 ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"
}

show_banner_2() {
    	echo "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                                                 ║ "
    	echo " ║                      SUBS                       ║ "
    	echo " ║                                                 ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"
}

show_banner_3() {
    	echo "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
   	echo " ║                                                 ║ "
    	echo " ║                    CLEAN-UP                     ║ "
    	echo " ║                                                 ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"
}

# -----------------------------------
# MENUS
# -----------------------------------

# Function for displaying the main menu
show_menu_0() {
    	show_banner_0
    	echo ""
    	echo ""
	echo "		SCRIPTS"
	echo " 1. For videos"
	echo " 2. For subtitles"
	echo " 3. For clean-up"
    	echo ""
    	echo ""
	echo " 0. Exit script"
    	echo ""

    	# Prompting the user to select an option
	echo -e "${BLUE}"
	prompt "Select: " ans
	echo "${RESET}"

   	# Handling the user's choice using a case statement
    	case $ans in
        	[vV]|[vV][iI][dD][eE][oO][sS]|"1")
            		show_menu_1
            		;;
        	[sS]|[sS][uU][bB][sS]|"2")
            		show_menu_2
           		;;
        	[cC]|[cC][lL][eE][aA][nN][uU][pP]|"3")
            		show_menu_3
            		;;
        	[eE]|[eE][xX][iI][tT]|"0")
            		# Exiting script
            		goodbye
            		;;
        	# Hidden options
        	[xX][2][6][5]|[1][6])
			clear
            		show_banner_1
            		x265
            		;;
        	[mM][3][uU][8]|[1][2])
			clear
            		show_banner_1
            		m3u8
            		;;
        	[yY][dD][lL]|[1][3])
			clear
            		show_banner_1
            		ydl
            		;;
        	[tT][uU][bB][iI]|[1][5])
			clear
            		show_banner_1
            		tubi
            		;;
        	[mM][eE][tT][aA][dD][aA][tT][aA]|[1][9])
			clear
            		show_banner_1
            		metadata
            		;;
        	[pP][lL][eE][xX]|[1][7])
			clear
            		show_banner_1
            		plex
            		;;
        	[aA][lL][lL]|[1][8])
			clear
            		show_banner_1
            		video_sub && sleep 1
            		c_all
            		;;
        	[eE][xX][tT][rR][aA][cC][tT]|[2][2])
			clear
            		show_banner_2
            		extract_srt
            		;;
        	[vV][tT][tT]|[2][3])
			clear
            		show_banner_2
            		convert_srt
            		;;
        	[cC][aA][lL][lL]|[3][4])
			clear
            		show_banner_3
            		c_all
            		;;
		# Handling invalid options
        	*)
            		echo -e "Invalid option. Please enter a valid option."
            		sleep 1
            		show_menu_0
            		;;
    	esac
}


# Function for displaying the VIDEOS menu
show_menu_1() {
	show_banner_0
	show_banner_1
	echo ""
  	echo "  1. Go back to Main Menu"
	echo ""
	echo "		DOWNLOAD"
  	echo "  2. Download m3u8 playlist"
	echo "  3. Download using youtube-dl"
	echo "  4. Download using yt-dlp"
	echo "  5. Download from tubi"
	echo ""
	echo " 		CONVERT"
  	echo "  6. Convert video to x265"
	echo "  7. Convert ONLY video"
	echo "  8. Convert video & subtitles"
	echo "  9. Encode metadata"
    	echo ""
	echo " 10. Go to SUBS Menu"
	echo " 11. Go to CLEAN-UP Menu"
    	echo ""
    	echo ""
    	echo "  0. Exit script"
    	echo ""

   	# Prompting the user to select an option
	echo -e "${BLUE}"
	prompt "Select: " ans
	echo "${RESET}"

	# Handling the user's choice using a case statement
	case $ans in
      		[mM][aA][iI][nN]|"1")
			clear
			show_banner_0
        		show_menu_0
        		;;
      		[mM]|[mM][3][uU][8]|[dD][2]|"2")
			clear
			show_banner_1
        		m3u8
        		;;
      		[yY]|[yY][dD][lL]|[dD][3]|"3")
			clear
        		show_banner_1
			ydl
        		;;
		[yY][tT]|[dD][4]|"4")
			clear
			show_banner_1
			ytdl
			;;
      		[tT]|[tT][uU][bI][iI]|[dD][5]|"5")
			clear
			show_banner_1
        		tubi
        		;;
      		[xX]|[xX][2][6][5]|[cC][6]|"6")
			clear
			show_banner_1
        		x265
        		;;
		[vV]|[vI][iI][vV][eE][oO]|[cC][7]|"7")
			clear
			show_banner_0
			plex
			c_ts
			;;
		[aA]|[aA][lL][lL]|[cC][8]|"8")
			clear
			show_banner_0
			video_sub && sleep 1
			c_ts
			c_mkv
			;;
		[lL]|[mM][eE][tT][aA][dD][aA][tT][aA]|[cC][9]|"9")
			clear
			show_banner_1
			metadata
			;;
		[sS]|[sS][uU][bB][sS]|"10")
			show_banner_2
			show_menu_2
			;;
		[cC]|[cC][lL][eE][aA][nN][uU][pP]|"11")
			show_banner_3
			show_menu_3
			;;
      		[eE]|[eE][xX][iI][Tt]|"0")
			# Exiting the menu
        		goodbye
        		;;
		# Handling invalid options
        	*)
            		echo -e "Invalid option. Please enter a valid option."
            		pause
            		show_menu_1
            		;;
    	esac
}

# Function for displaying the SUBS menu
show_menu_2() {
	show_banner_0
	show_banner_2
    	echo ""
    	echo ""
    	echo " 1. Go back to Main Menu"
    	echo ""
  	echo " 2. Extract subtitles"
  	echo " 3. Convert subtitles"
	echo ""
  	echo " 4. Go to VIDEOS Menu"
	echo " 5. Go to CLEAN-UP Menu"
    	echo ""
    	echo ""
    	echo " 0. Exit script"
    	echo ""

	# Prompting the user to select an option
  	echo -e "${BLUE}"
	prompt "Select: " ans
	echo "${RESET}"

	# Handling the user's choice using a case statement
    	case $ans in
      		[mM][aA][iI][nN]|"1")
        		show_banner_0
        		show_menu_0
        		;;
      		[eE]|[eE][xX][tT][rR][aA][cC][tT]|"2")
			clear
			show_banner_2
        		extract_srt
        		;;
      		[cC]|[cC][oO][nN][vV][eE][rR][tT]|"3")
			clear
			show_banner_2
        		convert_srt
        		;;
      		[vV]|[vV][iI][dD][eE][oO][sS]|"4")
			show_banner_1
        		show_menu_1
        		;;
		[cC]|[cC][lL][eE][aA][nN][uU][pP]|"5")
			show_banner_3
			show_menu_3
			;;
      		[eE]|[eE][xX][iI][tT]|[qQ]|"0")
			# Exiting the menu
        		goodbye
        		;;
		# Handling invalid options
        	*)
            		echo -e "Invalid option. Please enter a valid option."
            		pause
            		show_menu_2
            		;;
    	esac
}

# Function for displaying the CLEAN-UP menu
show_menu_3() {
	show_banner_0
	show_banner_3
    	echo ""
    	echo ""
    	echo " 1. Go back to Main Menu"
    	echo ""
  	echo " 2. Clear folder ts"
  	echo " 3. Clear folder mkv"
	echo " 4. Clear both folders"
	echo ""
	echo " 5. Go to VIDEOS Menu"
	echo " 6. Go to SUBS Menu"
    	echo ""
    	echo ""
    	echo " 0. Exit script"
    	echo ""

	# Prompting the user to select an option
  	echo -e "${BLUE}"
	prompt "Select: " ans
	echo "${RESET}"

	# Handling the user's choice using a case statement
    	case $ans in
      		[mM][aA][iI][nN]|"1")
        		show_banner_0
        		show_menu_0
        		;;
      		[c][tT][sS]|"2")
			clear
			show_banner_3
        		c_ts
        		;;
      		[c][mM][kK][vV]|"3")
			clear
			show_banner_3
        		c_mkv
        		;;
		[cC][aA][lL][lL]|"4")
			clear
			show_banner_3
			c_all
			;;
      		[vV]|[vV][iI][dD][eE][oO][sS]|"5")
			show_banner_1
        		show_menu_1
        		;;
		[sS]|[sS][uU][bB][sS]|"6")
			show_banner_2
			show_menu_2
			;;
      		"0")
			# Exiting the menu
        		goodbye
        		;;
		# Handling invalid options
        	*)
            		echo -e "Invalid option. Please enter a valid option."
            		pause
            		show_menu_3
            		;;
    	esac
}

# ----------------------------------
# VIDEO FORMULAS
# ----------------------------------


# Function for converting video files to x265 format using FFmpeg
# This function prompts the user for source extension, destination extension,
# source directory, and destination directory. It then loops through each file
# in the source directory with the specified source extension and converts
# it to x265 format with the specified destination extension.
#
x265() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                    x265 SCRIPT                  ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"

	# Prompt user for source extension (e.g. mkv, mp4, or avi)
	prompt "\nSource extension? (mkv, mp4, or avi) : " srcExt

	# Prompt user for destination extension (mkv or mp4)
	prompt "\nDestination extension? (mkv or mp4; default: mp4) : " destExt
	destExt=${destExt:-mp4}

	# Prompt user for for source directory
	prompt "\nSource directory? : " srcDir

	# Prompt user for for destination directory
	prompt "\nDestination directory? (default: DONE): " destDir
	destDir=${destDir:-DONE}

	# Loop through each file in the source directory with the specified source extension
	for filename in "$srcDir"/*.$srcExt
	do
    		basePath=${filename%.*}
		baseName=${basePath##*/}

		# Using FFmpeg to convert the source file to x265 format with the specified destination extension
		ffmpeg -i "$filename" -c:v libx265 -c:a copy -threads 2 "$destDir"/"$baseName"."$destExt"
	done

  	echo -e "Conversion from {srcExt} to {destExt} complete!\a"
	pause
	show_menu_1
}

# Function for converting M3U8 stream to TS format using FFmpeg
# This function prompts the user for input details such as source web address,
# movie name, release year, and language code. It then creates a directory,
# downloads the M3U8 stream, renames the directory, and converts the stream to TS format.
#
m3u8() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                 M3U8 to TS SCRIPT               ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Uncomment the following lines if source extension, destination extension,
	# and destination directory input is required
	#
	# prompt "\nSource extension? : " srcExt

	# Prompt user for destination extension
	prompt "\nDestination extension? (default: ts): " destExt "ts"

	# Prompt user for destination directory
	prompt "\nDestination directory? (default: ts): " destDir "ts"

	# Prompt user for source web address
	prompt "\nSource web-address? : " srcAdd

	# Prompt user for movie details
	prompt "\nMovie name? (include periods between words) : " baseName

	prompt "\nMovie release year? : " baseYear

	prompt "\nScene/channel of the movie? (default: TCM) : " baseScene "TCM"

	prompt "\nEnter the resolution (e.g., 480p, 720p, 1080p; default: 720p): " baseResolution "720p"

	# Prompt user for movie language (three-letter code)
	validLanguageCode=false
	while [ "$validLanguageCode" = false ]
	do
   		prompt "\nMovie language? (Enter a three-letter code, e.g., eng, spa, jpn, fre, zho; default: eng): " language "eng"

    		if [ ${#language} -eq 3 ]
		then
        		validLanguageCode=true
    		else
        		echo "Invalid language code. Please enter a three-letter code."
    		fi
	done

	# Create a directory based on movie name and release year
	dirName="${baseName} (${baseYear})"
	newname=`echo "$dirName" | tr '.' ' ' | sed 's/\(.*\) \([^ ]*[aA-zZ][aA-zZ]*$\)/\1.\2/g' `

    	mkdir "$dirName"
	mv "$dirName" "$newname"
	mv "$newname" ./DONE/

	# Download M3U8 stream and convert to TS format using FFmpeg
	ffmpeg -i $srcAdd -bsf:a aac_adtstoasc -c:v copy -c:a aac -map 0 -crf 50 -metadata:s:a:0 language=$language "$destDir"/"$baseName"."$baseYear"."$baseResolution".WEBRip.x265-"$baseScene"."$destExt"

  	echo -e "Conversion from {srcExt} to {destExt} complete!\a"
	sleep 1
	show_menu_1
}

# Function for downloading Movies & TV Shows from YouTube or Dailymotion using "$downloader"
# This function prompts the user for platform, type (tv or movie), and other details
# such as show name, season, episode, and resolution. It then downloads videos and subtitles
# using youtube-dl or yt-dlp and organizes them in a specific folder structure.
#
ydl() {
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                 Movies & TV Shows               ║ "
    	echo " ║              YOUTUBE-DL to MP4 SCRIPT           ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Prompt user for platform (YouTube or other)
	prompt "Is it YouTube or other? (Enter 'youtube' or 'other'; default: youtube): " platform "youtube"

	# Process based on the chosen platform
	if [ "$platform" == "youtube" ]
	then
		# For YouTube, prompt for TV show or movie
	    	prompt "\nIs it a TV show or a movie? (Enter 'tv' or 'movie'; default: tv): " type "tv"

		# Process based on the chosen type (tv or movie)
	    	if [ "$type" == "tv" ]
		then
			# For TV shows, prompt for show details and iterate through episodes
	       		prompt "\nEnter the show name (include periods between words): " show_name

			# Prompt for season and episode range
	        	prompt "Enter the season number (two digits; default: 01): " season_number "01"

	        	prompt "Enter the first episode number: " first_episode

	        	prompt "Enter the last episode number: " last_episode

	        	show_folder="${show_name}_YouTube"
	        	mkdir -p "$show_folder"

			# Iterate through episodes, prompting for URLs and downloading
	        	for ((episode = first_episode; episode <= last_episode; episode++))
			do
	            		episode_number=$(printf "%02d" "$episode")

				# Prompt for episode URL (skipping if blank)
	            		printf "\nEnter the URL for Season %s Episode %s (or leave it blank to skip): " "$season_number" "$episode_number"
	            		read -r episode_url

	            		if [ -z "$episode_url" ]
				then
	                		printf "Skipping Season %s Episode %s.\n" "$season_number" "$episode_number"
	                		continue
	            		fi

				# Generate filename and download video
	            		filename="${show_folder}/${show_name}.S${season_number}E${episode_number}.1080p.WEBRip.x264.mp4"
	            		printf "\nDownloading %s...\n" "$filename"
	            		youtube-dl -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]' "$episode_url" --add-metadata -o "$filename"

				 # Download subtitles and convert to SRT format
	            		printf "\nDownloading subtitles for %s...\n" "$filename"
	            		youtube-dl --write-sub --sub-lang en,en-US,en-CA,es,ja --convert-subs srt --skip-download -o "${filename%.*}" "$episode_url"

				printf "\nConverting subtitles to SRT format...\n"
	        		vtt_files=("${filename%.*}"*.vtt)
	        		for vtt_file in "${vtt_files[@]}"
				do
	            			srt_file="${vtt_file%.*}.srt"
	            			ffmpeg -i "$vtt_file" "$srt_file" -y
	            			rm "$vtt_file"
	            			printf "Converted %s to %s and removed the VTT file.\n" "$vtt_file" "$srt_file"
	        		done

				printf "\nDownloaded and converted subtitles for %s.\n" "$filename"
	    		done

	        	printf "\nAll episodes downloaded successfully.\n"

	   	elif [ "$type" == "movie" ]
		then
			# For movies, prompt for movie details and download
	        	prompt "\nEnter the name of the movie (include periods between words): " movie_name

			prompt "\nEnter the year of the movie : " movie_year

			prompt "Enter the resolution (e.g., 480p, 720p, 1080p): " resolution

	        	prompt "Enter the movie URL: " movie_url

			# Generate filename and download video
	        	filename="${movie_name}.${movie_year}.${resolution}.WEBRip.x264.mp4"
	        	printf "\nDownloading %s...\n" "$filename"
	        	youtube-dl -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]' "$movie_url" --add-metadata -o "$filename"

			# Download subtitles and convert to SRT format
			printf "\nDownloading subtitles for %s.\n" "$filename"
			youtube-dl --write-sub --sub-lang en,en-US,en-CA,es --convert-subs srt --skip-download -o "${filename%.*}" "$movie_url"
			
			printf "\nConverting subtitles to SRT format...\n"
			vtt_files=("${filename%.*}"*.vtt)
			for vtt_file in "${vtt_files[@]}"
			do
				srt_file="${vtt_file%.*}.srt"
				ffmpeg -i "$vtt_file" "$srt_file" -y
				rm "$vtt_file"
				printf "Converted %s to %s and removed the VTT file.\n" "$vtt_file" "$srt_file"
			done

			printf "\nDownloaded and converted subtitles for %s.\n" "$filename"
	    	
		else
			# Invalid type entered
	        	printf "\nInvalid type. Please enter 'tv' or 'movie'.\n"
	        	exit 1
	    	fi

	elif [ "$platform" == "other" ]
	then
		# For other, prompt for TV show or movie
	    	prompt "\nIs it a TV show or a movie? (Enter 'tv' or 'movie'): " type

		# Process based on the chosen type (tv or movie)
	    	if [ "$type" == "tv" ]
		then
			# For TV shows, prompt for show details and iterate through episodes
	        	prompt "\nEnter the show name (include periods between words): " show_name

			prompt "Enter the resolution (e.g., 480p, 720p, 1080p): " resolution

	        	prompt "Enter the season number (two digits; default: 01): " season_number "01"

	        	prompt "Enter the first episode number (two digits): " first_episode

	        	prompt "Enter the last episode number (two digits): " last_episode

	        	show_folder="${show_name}_Other"
	        	mkdir -p "$show_folder"

			# Iterate through episodes, prompting for URLs and downloading
	        	for ((episode = first_episode; episode <= last_episode; episode++))
			do
	            		episode_number=$(printf "%02d" "$episode")

				# Prompt for episode URL (skipping if blank)
	            		printf "\nEnter the URL for Season %s Episode %s (or leave it blank to skip): " "$season_number" "$episode_number"
	            		read -r episode_url

	            		if [ -z "$episode_url" ]; then
	                		printf "Skipping Season %s Episode %s.\n" "$season_number" "$episode_number"
	                		continue
	            		fi

				# Generate filename and download video
	            		filename="${show_folder}/${show_name}.S${season_number}E${episode_number}.${resolution}.WEBRip.x264.mp4"
	            		printf "\nDownloading %s...\n" "$filename"
	            		youtube-dl -f best "$episode_url" --add-metadata -o "$filename"

	            		printf "\nDownloaded %s.\n" "$filename"
	        	done

	        	printf "\nAll episodes downloaded successfully.\n"

	    	elif [ "$type" == "movie" ]
		then
			# For movies, prompt for movie details and download
	        	prompt "\nEnter the name of the movie (include periods between words): " movie_name

			prompt "\nEnter the year of the movie: " movie_year

	        	prompt "Enter the resolution (e.g., 480p, 720p, 1080p): " resolution

			prompt "Enter the movie URL: " movie_url

			# Generate filename and download video
	        	filename="${movie_name}.${movie_year}.${resolution}.WEBRip.x264.mp4"
	        	printf "\nDownloading %s...\n" "$filename"
	        	youtube-dl -f best "$movie_url" --add-metadata -o "$filename"

	        	printf "\nDownloaded %s.\n" "$filename"

	    	else
			# Invalid type entered
	        	printf "\nInvalid type. Please enter 'tv' or 'movie'.\n"
	        	exit 1
	    	fi

	else
		# Invalid platform entered
	    	printf "\nInvalid platform. Please enter 'youtube' or 'other'.\n"
	    	exit 1
	fi
	pause
	show_menu_1

}

ytdl() {
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                 Movies & TV Shows               ║ "
    	echo " ║                YT-DLP to MP4 SCRIPT             ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Prompt user for platform (YouTube or other)
	prompt "Is it YouTube or other? (Enter 'youtube' or 'other'; default: youtube): " platform "youtube"

	# Process based on the chosen platform
	if [ "$platform" == "youtube" ]
	then
		# For YouTube, prompt for TV show or movie
	    	prompt "Is it a TV show or a movie? (Enter 'tv' or 'movie'; default: tv): " type "tv"

		# Process based on the chosen type (tv or movie)
	    	if [ "$type" == "tv" ]
		then
			# For TV shows, prompt for show details and iterate through episodes
	       		prompt "Enter the show name (include periods between words): " show_name

			# Prompt for season and episode range
	        	prompt "Enter the season number (two digits; default: 01): " season_number "01"

	        	prompt "Enter the first episode number: " first_episode

	        	prompt "Enter the last episode number: " last_episode

	        	show_folder="${show_name}_YouTube"
	        	mkdir -p "$show_folder"

			# Iterate through episodes, prompting for URLs and downloading
	        	for ((episode = first_episode; episode <= last_episode; episode++))
			do
	            		episode_number=$(printf "%02d" "$episode")

				# Prompt for episode URL (skipping if blank)
				printf "\nEnter the URL for Season %s Episode %s (or leave it blank to skip): " "$season_number" "$episode_number"
	            		read -r episode_url

	            		if [ -z "$episode_url" ]
				then
	                		printf "Skipping Season %s Episode %s.\n" "$season_number" "$episode_number"
	                		continue
	            		fi

				# Generate filename and download video
	            		filename="${show_folder}/${show_name}.S${season_number}E${episode_number}.1080p.WEBRip.x264.mp4"
	            		printf "\nDownloading %s...\n" "$filename"
				yt-dlp -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]' "$episode_url" --add-metadata -o "$filename"

				 # Download subtitles and convert to SRT format
	            		printf "\nDownloading subtitles for %s...\n" "$filename"
				yt-dlp --write-sub --sub-lang en,en-US,en-CA,es,ja --convert-subs srt --skip-download -o "${filename%.*}" "$episode_url"

				printf "\nConverting subtitles to SRT format...\n"
	        		vtt_files=("${filename%.*}"*.vtt)
	        		for vtt_file in "${vtt_files[@]}"
				do
	            			srt_file="${vtt_file%.*}.srt"
	            			ffmpeg -i "$vtt_file" "$srt_file" -y
	            			rm "$vtt_file"
	            			printf "Converted %s to %s and removed the VTT file.\n" "$vtt_file" "$srt_file"
	        		done

				printf "\nDownloaded and converted subtitles for %s.\n" "$filename"
	    		done

	        	printf "\nAll episodes downloaded successfully.\n"

	   	elif [ "$type" == "movie" ]
		then
			# For movies, prompt for movie details and download
	        	prompt "\nEnter the name of the movie (include periods between words): " movie_name

			prompt "\nEnter the year of the movie : " movie_year

			prompt "\nEnter the resolution (e.g., 480p, 720p, 1080p): " resolution

	        	prompt "\nEnter the movie URL: " movie_url

			# Generate filename and download video
	        	filename="${movie_name}.${movie_year}.${resolution}.WEBRip.x264.mp4"
	        	printf "\nDownloading %s...\n" "$filename"
			yt-dlp -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]' "$movie_url" --add-metadata -o "$filename"

			# Download subtitles and convert to SRT format
			printf "\nDownloading subtitles for %s.\n" "$filename"
			yt-dlp --write-sub --sub-lang en,en-US,en-CA,es --convert-subs srt --skip-download -o "${filename%.*}" "$movie_url"
			
			printf "\nConverting subtitles to SRT format...\n"
			vtt_files=("${filename%.*}"*.vtt)
			for vtt_file in "${vtt_files[@]}"
			do
				srt_file="${vtt_file%.*}.srt"
				ffmpeg -i "$vtt_file" "$srt_file" -y
				rm "$vtt_file"
				printf "Converted %s to %s and removed the VTT file.\n" "$vtt_file" "$srt_file"
			done

			printf "\nDownloaded and converted subtitles for %s.\n" "$filename"
	    	
		else
			# Invalid type entered
	        	printf "\nInvalid type. Please enter 'tv' or 'movie'.\n"
	        	exit 1
	    	fi

	elif [ "$platform" == "other" ]
	then
		# For other, prompt for TV show or movie
	    	prompt "Is it a TV show or a movie? (Enter 'tv' or 'movie'): " type

		# Process based on the chosen type (tv or movie)
	    	if [ "$type" == "tv" ]
		then
			# For TV shows, prompt for show details and iterate through episodes
	        	prompt "\nEnter the show name (include periods between words): " show_name

			prompt "Enter the resolution (e.g., 480p, 720p, 1080p): " resolution

	        	prompt "Enter the season number (two digits; default: 01): " season_number "01"

	        	prompt "Enter the first episode number (two digits): " first_episode

	        	prompt "Enter the last episode number (two digits): " last_episode

	        	show_folder="${show_name}_Other"
	        	mkdir -p "$show_folder"

			# Iterate through episodes, prompting for URLs and downloading
	        	for ((episode = first_episode; episode <= last_episode; episode++))
			do
	            		episode_number=$(printf "%02d" "$episode")

				# Prompt for episode URL (skipping if blank)
				printf "\nEnter the URL for Season %s Episode %s (or leave it blank to skip): " "$season_number" "$episode_number"
	            		read -r episode_url

	            		if [ -z "$episode_url" ]; then
	                		printf "Skipping Season %s Episode %s.\n" "$season_number" "$episode_number"
	                		continue
	            		fi

				# Generate filename and download video
	            		filename="${show_folder}/${show_name}.S${season_number}E${episode_number}.${resolution}.WEBRip.x264.mp4"
	            		printf "\nDownloading %s...\n" "$filename"
				yt-dlp -f best "$episode_url" --add-metadata -o "$filename"

	            		printf "\nDownloaded %s.\n" "$filename"
	        	done

	        	printf "\nAll episodes downloaded successfully.\n"

	    	elif [ "$type" == "movie" ]
		then
			# For movies, prompt for movie details and download
	        	prompt "\nEnter the name of the movie (include periods between words): " movie_name

			prompt "\nEnter the year of the movie: " movie_year

	        	prompt "Enter the resolution (e.g., 480p, 720p, 1080p): " resolution

			prompt "Enter the movie URL: " movie_url

			# Generate filename and download video
	        	filename="${movie_name}.${movie_year}.${resolution}.WEBRip.x264.mp4"
	        	printf "\nDownloading %s...\n" "$filename"
			yt-dlp -f best "$movie_url" --add-metadata -o "$filename"

	        	printf "\nDownloaded %s.\n" "$filename"

	    	else
			# Invalid type entered
	        	printf "\nInvalid type. Please enter 'tv' or 'movie'.\n"
	        	exit 1
	    	fi

	else
		# Invalid platform entered
	    	printf "\nInvalid platform. Please enter 'youtube' or 'other'.\n"
	    	exit 1
	fi
	pause
	show_menu_1
}

# Function for converting video files and extracting subtitles
# This function loops through each .ts file in the 'ts' directory,
# converts them to .mkv with the same metadata, extracts subtitles,
# and then converts the resulting .mkv files to .mp4 with specific settings.
#
video_sub() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                Video & Subs SCRIPT              ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Loop through each .ts file in the 'ts' directory
	for filename in ts/*.ts
	do
		# Extracting the base name and path without the extension
	    	basePath=${filename%.*}
	    	baseName=${basePath##*/}

		# Using FFmpeg to convert .ts to .mkv with the same metadata
		ffmpeg -i "$filename" -map 0 -c copy -map_metadata 0 "mkv/$baseName.mkv"
	done

	# Pause for a short duration
	sleep 1

	# Loop through each .ts file again
	for filename in ts/*.ts
	do
		# Extracting the base name and path without the extension
	    	basePath=${filename%.*}
	    	baseName=${basePath##*/}

		# Using FFmpeg to extract subtitles from .ts and save as .srt
		ffmpeg -f lavfi -i "movie="$filename"[out0+subcc]" -map s srt/"$baseName".en.srt
	done
			
	# Pause for a short duration
	sleep 1

	# Loop through each .mkv file in the 'mkv' directory
	for filename in mkv/*.mkv
	do
		# Extracting the base name and path without the extension
	    	basePath=${filename%.*}
	    	baseName=${basePath##*/}

		# Using FFmpeg to convert .mkv to .mp4 with specific settings
		ffmpeg -i "$filename" -map 0 -c:v libx265 -c:a copy -map_metadata 0 -threads 3 "DONE/$baseName.mp4"
	done

	echo -e "Conversion complete!\a"
	pause
	show_menu_1
}

# Function for downloading and merging video and audio files for Tubi episodes
# This function prompts the user for show details, including the show name,
# first and last episode numbers, and web addresses for video and audio files.
# It then downloads the video and audio files for each episode, merges them using FFmpeg,
# and saves the merged output file with a specific naming convention.
#
tubi() {
	check_ffmpeg
	check_wget
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                   tubi SCRIPT                   ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Prompting the user for show details
	prompt "Enter the name of the show: " show_name

	prompt "Enter the first episode number: " first_episode

	prompt "Enter the last episode number: " last_episode

	# Loop through the specified range of episodes
	for ((episode_number = first_episode; episode_number <= last_episode; episode_number++))
	do
		# Prompting the user for video and audio URLs for each episode
	    	prompt "Enter the web address for video file of episode %02d: " "${episode_number}" video_url

	   	prompt "Enter the web address for audio file of episode %02d: " "${episode_number}" audio_url

		# Generating file names based on user input
	    	video_file="${show_name}_video_episode_$(printf "%02d" "${episode_number}").mp4"
	    	audio_file="${show_name}_audio_episode_$(printf "%02d" "${episode_number}").mp4"
	    	output_file="${show_name}.S01E$(printf "%02d" "${episode_number}").WEBRip.x264.mp4"

		# Downloading video and audio files
	    	printf "Downloading video for episode %02d...\n" "${episode_number}"
	    	wget -O "${video_file}" "${video_url}"

	    	printf "Downloading audio for episode %02d...\n" "${episode_number}"
	    	wget -O "${audio_file}" "${audio_url}"

		# Merging video and audio files using FFmpeg
	    	ffmpeg -i "${video_file}" -i "${audio_file}" -c:v copy -c:a copy "${output_file}"

	    	printf "Video and audio files merged for episode %02d. Output file: %s\n" "${episode_number}" "${output_file}"

		# Removing downloaded video and audio files
	    	rm "${video_file}" "${audio_file}"
	done

	echo -e "Download complete!\a"
	pause
	show_menu_1
}

# Function to update language metadata in MP4 video files
# This function prompts the user to enter the folder path containing video files,
# iterates through each .mp4 file in the folder, prompts for a three-letter language code,
# and updates the metadata language using FFmpeg, saving the output files in a 'Metadata' folder.
#
metadata() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║          Encode Language Metadata SCRIPT        ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"

	# Prompting the user to enter the folder path
	prompt "Enter the folder path where the video files are located: " folder_path

	# Checking if the folder exists
	if [ -d "$folder_path" ]; then
		# Creating the Metadata folder if it doesn't exist
		mkdir -p "$folder_path/Metadata"

		# Moving to the specified folder
	   	cd "$folder_path"

		# Looping through each file in the folder
		for file in *
		do
			# Checking if the file is an .mp4 video file
	        	if [[ -f "$file" && "$file" != "metadata.sh" && "$file" != "Metadata" && $(file -b --mime-type "$file" | grep -c "video/mp4") -eq 1 ]]; then
				# Prompting the user to enter the three-letter language code
	            		prompt "Enter the three-letter language code for $file (e.g., eng, spa, fre, zho): " language

				# Checking if the user entered "abort" to stop the script
	            		if [[ "$language" == "abort" ]]
				then
	                		echo "Script aborted by user."
	                		exit 1
	           		fi

				# Setting the output file name
	            		output_file="Metadata/$file"

				# Using ffmpeg to change the metadata language and save the output file
	            		ffmpeg -i "$file" -metadata:s:a:0 language="$language" -codec copy "$output_file"

	            		echo "Updated metadata for $file"
	        	fi
	    	done

	    	echo "Metadata files are saved in $folder_path/Metadata"
	else
		echo "Folder not found."
	fi

	echo -e "Metadata has been encoded!\a"
	pause
	show_menu_1
}

# Function to convert TS to MKV for PLEX compatibility
# This function prompts the user for source and destination directories,
# source and destination extensions, then iterates through all files
# in the source directory with the specified source extension,
# converting each to MKV format using FFmpeg and saving them in the destination directory
# with the specified destination extension.
#
plex() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║               plex TS to MKV SCRIPT             ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Prompting the user for the source extension (e.g., ts)
  	prompt "Source extension? : " srcExt

	# Prompting the user for the destination extension (e.g., mkv)
  	prompt "Destination extension? : " destExt

	# Prompting the user for the source directory
  	prompt "Source directory? : " srcDir

	# Prompting the user for the destination directory
  	prompt "Destination directory? : " destDir

	# Loop through each file in the source directory with the specified source extension
  	for filename in "$srcDir"/*.$srcExt
	do
		# Extracting the base name and path without the extension
    		basePath=${filename%.*}
    		baseName=${basePath##*/}
	
		# Using FFmpeg to convert TS to MKV and save the file in the destination directory
    		ffmpeg -i $filename -map 0 -c copy "$destDir"/"$baseName"."$destExt"
  	done

  	echo -e "Conversion from ${srcExt} to ${destExt} complete!\a"
	pause
	show_menu_1
}

# -----------------------------------
# SUBTITLE FORMULAS
# -----------------------------------

# Function to extract subtitles from video files and save as SRT
# This function prompts the user for source and destination directories,
# source and destination extensions, then iterates through all files
# in the source directory with the specified source extension,
# extracting subtitles using FFmpeg, and saving them in the destination directory
# with the specified destination extension.
#
extract_srt() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║              Extract subtitles SCRIPT           ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Prompting the user for the source extension (e.g., mp4, mkv)
	prompt "Source extension? : " srcExt

	# Prompting the user for the destination extension (e.g., srt)
	prompt "Destination extension? (default: srt): " destExt
	destExt=${destExt:-srt}

	# Prompting the user for the source directory
  	prompt "Source directory? : " srcDir

	# Prompting the user for the destination directory
  	prompt "Destination directory? : " destDir
	destDir=${destDir:-srt}

	# Loop through each file in the source directory with the specified source extension
  	for filename in "$srcDir"/*.$srcExt
	do
		# Extracting the base name and path without the extension
  		basePath=${filename%.*}
    		baseName=${basePath##*/}

		# Using FFmpeg to extract subtitles and save as SRT in the destination directory
  		ffmpeg -f lavfi -i "movie="$filename"[out0+subcc]" -map s "$destDir"/"$baseName".en."$destExt"
  	done

  	echo -e "Conversion from ${srcExt} to ${destExt} complete!\a"
	pause
	show_menu_2
}

# Function to convert VTT subtitles to SRT format
# This function prompts the user for source and destination directories,
# then iterates through all VTT files in the source directory,
# converting each to SRT format using FFmpeg and saving them in the destination directory.
#
convert_srt() {
	check_ffmpeg
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║              Convert Subtitles SCRIPT           ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"

	# Prompting the user for the source directory
  	prompt "Source directory? (default: vtt): " srcDir
	srcDir=${srcDir:-vtt}

	# Prompting the user for the destination directory
  	prompt "Destination directory? (default: srt): " destDir
	destDir=${destDir:-srt}

	# Loop through each VTT file in the source directory
  	for filename in "$srcDir"/*.vtt
	do
		# Extracting the base name and path without the extension
  		basePath=${filename%.*}
    		baseName=${basePath##*/}

		# Using FFmpeg to convert VTT to SRT and save the file in the destination directory
  		ffmpeg -i $filename "$destDir"/"$baseName".srt
  	done

  	echo -e "Conversion from vtt to srt complete!\a"
	pause
	show_menu_2
}

# -----------------------------------
# CLEAN-UP FORMULAS
# -----------------------------------

# Function to clean up 'ts' folder
# This function prompts the user for confirmation and, if confirmed, removes all files with .ts extension in the 'ts' folder.
#
c_ts() {
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                CLEAN-UP ts SCRIPT               ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"


	# Prompting the user for confirmation
	prompt 'Do you want to clear ts folder (y/N)? ' ans

	# Checking if the user entered 'y' or 'Y' to proceed with cleanup
	if [ "$ans" != "${ans#[Yy]}" ]
	then
		# Removing all files with .ts extension in the 'ts' folder
		rm -r ./ts/*.ts

		echo -e "TS folder cleared!\a"
		sleep 1
		show_menu_3
	fi
}

# Function to clean up 'mkv' folder
# This function prompts the user for confirmation and, if confirmed, removes all files with .mkv extension in the 'mkv' folder.
#
c_mkv() {
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                CLEAN-UP mkv SCRIPT              ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"

	# Prompting the user for confirmation
	prompt 'Do you want to clear mkv folder (y/N)? ' ans

	# Checking if the user entered 'y' or 'Y' to proceed with cleanup
	if [ "$ans" != "${ans#[Yy]}" ]
	then
		# Removing all files with .mkv extension in the 'mkv' folder
		rm -r ./mkv/*.mkv

		echo -e "MKV folder cleared!\a"
		sleep 1
		show_menu_3
	fi
}

# Function to clean up all folders
# This function prompts the user for confirmation and, if confirmed, removes all files in the 'ts' and 'mkv' folders.
#
c_all() {
	echo -e "${BLUE}"
    	echo " ╔═════════════════════════════════════════════════╗ "
    	echo " ║                Full CLEAN-UP SCRIPT             ║ "
    	echo " ╚═════════════════════════════════════════════════╝ ""${RESET}"

	# Prompting the user for confirmation
	prompt 'Do you want to clear all folders (y/N)? ' ans

	# Checking if the user entered 'y' or 'Y' to proceed with cleanup
	if [ "$ans" != "${ans#[Yy]}" ]
	then
		# Removing all files with .ts extension in the 'ts' folder
 		rm -r ./ts/*.ts

		# Removing all files with .mkv extension in the 'mkv' folder
		rm -r ./mkv/*.

		echo -e "All folders cleared!\a"
		sleep 1
		show_menu_3
	fi
}

# -----------------------------------
# INFINITE LOOP
# -----------------------------------

while true
do
	show_banner_0 && show_menu_${main_menu}
done
